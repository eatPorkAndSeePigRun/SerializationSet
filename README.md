# SerializationSet

## 题目

使用 `ordered link list` 实现一个 `set`， 假设 `set` 里面保存的都是整数，并且 `set` 具有下面的功能

```golang
contain(item int) bool

add(item int) bool

remove(item int) bool
```

要求：

1. 实现该 `set`

2. 支持并发访问，并且优化并发访问度

3. 证明问题 `2` 的解决方法的正确性

## 思路

- 使用粒度小的锁，为了优化并发。对于`ordered link list`的每一个`node`都放一个锁，但每次访问节点，需要先获得前一个节点`pre`和当前节点`cur`的锁；同理，当不再访问时，要释放当前节点`cur`和前一个节点`pre`的锁。这样保证每次并发对链表的修改后，整个链表的数据结构还是正确。

- 预防死锁，通过正确的加锁顺序串行化多个`goroutine`的修改。进行任何修改操作，每个`goroutine`加锁的顺序都是从链表的头节点往尾节点的。对于释放锁，则是相反顺序，从链表的尾节点到头节点。

- 在`contain()`、`add()`、`remove()`内部，每次修改时，需要先获得相应节点的锁，才进行修改，以防止破坏该有序链表的数据结构。

## 其他

主要代码存放在`src\set.go`里，重点在于`contain()`、`add()`、`remove()`加锁放锁的顺序，以防死锁，并且这三个函数并发时，不相互影响。

## 其他思路

- 如果是为了编程简单，可以使用粒度大的锁，比如只用一个锁去锁住整个链表，进行相关操作时只去活得这个锁就好。此种思想类似于数据库的表锁，粒度比较大。
